<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Fire Seed</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/15.1.22/Tone.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0D0D0D; overflow: hidden; font-family: monospace; }
    canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; touch-action: none; }
    #startScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; }
    #startScreen.hidden { display: none; }
    .background-grid { position: absolute; width: 60%; height: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); background-image: linear-gradient(#1A1A1A 1px, transparent 1px), linear-gradient(90deg, #1A1A1A 1px, transparent 1px); background-size: 40px 40px; opacity: 0.6; }
    .corner-bracket { position: absolute; width: 40px; height: 40px; border-color: #FF6B1A; border-style: solid; border-width: 0; opacity: 0.5; }
    .corner-bracket.tl { top: 10%; left: 10%; border-top-width: 2px; border-left-width: 2px; }
    .corner-bracket.tr { top: 10%; right: 10%; border-top-width: 2px; border-right-width: 2px; }
    .corner-bracket.bl { bottom: 10%; left: 10%; border-bottom-width: 2px; border-left-width: 2px; }
    .corner-bracket.br { bottom: 10%; right: 10%; border-bottom-width: 2px; border-right-width: 2px; }
    .title-container { position: relative; z-index: 10; text-align: center; }
    .title { font-size: 72px; font-weight: bold; text-transform: uppercase; letter-spacing: 0.3em; color: #FF6B1A; filter: url(#titleBlur); }
    .subtitle { font-size: 18px; color: #666666; margin-top: 20px; animation: fadeInOut 4s infinite; }
    @keyframes fadeInOut { 0%, 25% { opacity: 0; } 50%, 75% { opacity: 1; } 100% { opacity: 0; } }
    #gameUI { position: fixed; top: 20px; left: 20px; color: #FFFAF0; font-size: 16px; z-index: 50; display: none; }
    #gameUI.visible { display: block; }
    #levelInfo { margin-bottom: 10px; }
    #scoreInfo { color: #FF6B1A; }
    #highScoreInfo { color: #666666; font-size: 14px; margin-top: 5px; }
    #resultScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 200; background: rgba(13, 13, 13, 0.9); display: none; }
    #resultScreen.visible { display: flex; }
    #resultScreen h1 { font-size: 48px; color: #FF6B1A; text-transform: uppercase; letter-spacing: 0.2em; margin-bottom: 20px; }
    #resultScreen p { color: #FFFAF0; font-size: 20px; margin-bottom: 30px; }
    #nextLevelBtn, #restartBtn { padding: 15px 40px; font-size: 18px; background: #FF6B1A; color: #0D0D0D; border: none; cursor: pointer; font-family: monospace; text-transform: uppercase; letter-spacing: 0.1em; }
    #nextLevelBtn:hover, #restartBtn:hover { background: #FFFAF0; }
    .vignette { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.4) 100%); z-index: 10; }
    a { pointer-events: auto; }
  </style>
  <script type="importmap">
  { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.183.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.0/examples/jsm/" } }
  </script>
</head>
<body>
  <div class="vignette"></div>
  <canvas id="gameCanvas"></canvas>
  <div id="startScreen">
    <div class="background-grid"></div>
    <div class="corner-bracket tl"></div>
    <div class="corner-bracket tr"></div>
    <div class="corner-bracket bl"></div>
    <div class="corner-bracket br"></div>
    <svg style="position:absolute;width:0;height:0;"><defs><filter id="titleBlur"><feGaussianBlur stdDeviation="6" result="blur"><animate attributeName="stdDeviation" values="6;10;6" dur="2s" repeatCount="indefinite"/></feGaussianBlur></filter></defs></svg>
    <div class="title-container">
      <h1 class="title">FIRE SEED</h1>
      <p class="subtitle">TAP TO IGNITE</p>
    </div>
  </div>
  <div id="gameUI"><div id="levelInfo"></div><div id="scoreInfo"></div><div id="highScoreInfo"></div></div>
  <div id="resultScreen"><h1 id="resultTitle"></h1><p id="resultScore"></p><button id="nextLevelBtn">Next Level</button><button id="restartBtn" style="display:none;">Play Again</button></div>
  <a href="https://github.com/nishivector/fire-seed" target="_blank" style="position:fixed;bottom:16px;right:16px;color:rgba(255,255,255,0.4);font-size:12px;text-decoration:none;font-family:monospace;z-index:1000;">GitHub â†—</a>
  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    const CELL_SIZE = 40;
    const COLORS = { background: 0x0D0D0D, primary: 0xFF6B1A, secondary: 0x1A1A2E, accent: 0xFFFAF0 };
    const LEVELS = [
      { gridSize: 5, water: 0, fuel: 8, damp: 0, par: 8, name: 'First Spark' },
      { gridSize: 6, water: 2, fuel: 14, damp: 0, par: 14, name: 'The River' },
      { gridSize: 7, water: 4, fuel: 22, damp: 2, par: 22, name: 'Dampening' },
      { gridSize: 8, water: 7, fuel: 32, damp: 5, par: 32, name: 'The Maze' },
      { gridSize: 9, water: 12, fuel: 45, damp: 10, par: 45, name: 'Inferno' }
    ];

    let gameState = 'start';
    let currentLevel = 0;
    let grid = [];
    let gridSize = 5;
    let scene, camera, renderer, composer;
    let cellMeshes = [];
    let clock = new THREE.Clock();
    let audioInitialized = false;
    let padSynth = null, pianoSynth = null, reverb = null, noiseSynth = null;
    let score = 0, highScore = 0, gameStartTime = 0, allFuelIgnitedTime = null, fireActiveCount = 0, hasEverIgnited = false;
    let idleCells = [], idleMeshes = [];

    const canvas = document.getElementById('gameCanvas');
    const startScreen = document.getElementById('startScreen');
    const gameUI = document.getElementById('gameUI');
    const levelInfo = document.getElementById('levelInfo');
    const scoreInfo = document.getElementById('scoreInfo');
    const highScoreInfo = document.getElementById('highScoreInfo');
    const resultScreen = document.getElementById('resultScreen');
    const resultTitle = document.getElementById('resultTitle');
    const resultScore = document.getElementById('resultScore');
    const nextLevelBtn = document.getElementById('nextLevelBtn');
    const restartBtn = document.getElementById('restartBtn');

    const SCORE_KEY = 'fire-seed-highscore';
    function getHighScore() { return parseInt(localStorage.getItem(SCORE_KEY) || '0'); }
    function saveHighScore(s) { if (s > getHighScore()) localStorage.setItem(SCORE_KEY, s); }

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(COLORS.background);
      const aspect = window.innerWidth / window.innerHeight;
      const frustumSize = 400;
      if (aspect < 1) {
        camera = new THREE.OrthographicCamera(-frustumSize * aspect / 2, frustumSize * aspect / 2, frustumSize / 2, -frustumSize / 2, 0.1, 1000);
      } else {
        camera = new THREE.OrthographicCamera(-frustumSize / 2, frustumSize / 2, frustumSize / aspect / 2, -frustumSize / aspect / 2, 0.1, 1000);
      }
      camera.position.z = 500;
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.6, 0.8));
      window.addEventListener('resize', onResize);
    }

    function onResize() {
      const aspect = window.innerWidth / window.innerHeight;
      const frustumSize = 400;
      if (aspect < 1) {
        camera.left = -frustumSize * aspect / 2; camera.right = frustumSize * aspect / 2;
        camera.top = frustumSize / 2; camera.bottom = -frustumSize / 2;
      } else {
        camera.left = -frustumSize / 2; camera.right = frustumSize / 2;
        camera.top = frustumSize / aspect / 2; camera.bottom = -frustumSize / aspect / 2;
      }
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    async function initAudio() {
      if (audioInitialized) return;
      await Tone.start();
      reverb = new Tone.Reverb({ decay: 4, wet: 0.5 }).toDestination();
      padSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.5, decay: 1, sustain: 0.8, release: 2 } }).connect(reverb);
      padSynth.volume.value = -12;
      pianoSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.5, sustain: 0.3, release: 1 } }).connect(reverb);
      pianoSynth.volume.value = -8;
      noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0 } }).toDestination();
      noiseSynth.volume.value = -20;
      padSynth.triggerAttack('A1');
      const barLength = (60 / 72) * 4;
      const randomInterval = () => Math.floor(8 + Math.random() * 4) * barLength * 1000;
      const playPiano = () => {
        if (gameState !== 'playing' && gameState !== 'start') return;
        const notes = ['E3', 'G3', 'E4', 'G4', 'C4', 'A3'];
        pianoSynth.triggerAttackRelease(notes[Math.floor(Math.random() * notes.length)], '2n');
        setTimeout(playPiano, randomInterval());
      };
      setTimeout(playPiano, randomInterval());
      audioInitialized = true;
    }

    function playSeedSound() { if (!audioInitialized) return; const osc = new Tone.Oscillator({ type: 'sine', frequency: { 880: 440 }, duration: 0.1 }).toDestination(); osc.start(); osc.stop(Tone.now() + 0.15); }
    function playIgniteSound() { if (!audioInitialized) return; const filter = new Tone.Filter(2000 + Math.random() * 400 - 200, 'bandpass').toDestination(); noiseSynth.connect(filter); noiseSynth.triggerAttackRelease(0.2); noiseSynth.disconnect(filter); }
    function playDampSound() { if (!audioInitialized) return; const osc = new Tone.Oscillator({ type: 'sawtooth', frequency: { 300: 150 }, duration: 0.3 }).toDestination(); osc.start(); osc.stop(Tone.now() + 0.3); }
    function playWinSound() { if (!audioInitialized) return; padSynth.triggerAttack('A3'); setTimeout(() => pianoSynth.triggerAttackRelease('C4', '8n'), 150); setTimeout(() => pianoSynth.triggerAttackRelease('E4', '4n'), 300); setTimeout(() => padSynth.triggerRelease('A3'), 3000); }
    function playLoseSound() { if (!audioInitialized) return; padSynth.triggerReleaseAll(); setTimeout(() => { const osc = new Tone.Oscillator({ type: 'sine', frequency: 40 }).toDestination(); osc.volume.value = -10; osc.start(); osc.stop(Tone.now() + 2); }, 2000); }

    function createGrid(size) { grid = []; for (let y = 0; y < size; y++) { grid[y] = []; for (let x = 0; x < size; x++) grid[y][x] = { type: 'empty', burning: false, burnTime: 0 }; } }

    function placeWaterBarriers(count) { let placed = 0, attempts = 0; while (placed < count && attempts < 100) { const x = Math.floor(Math.random() * gridSize), y = Math.floor(Math.random() * gridSize); if (grid[y][x].type === 'empty') { grid[y][x].type = 'water'; placed++; } attempts++; } }

    function placeFuelCells(count, dampCount = 0) {
      let cells = []; for (let y = 0; y < gridSize; y++) for (let x = 0; x < gridSize; x++) if (grid[y][x].type === 'empty') cells.push({ x, y });
      for (let i = cells.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [cells[i], cells[j]] = [cells[j], cells[i]]; }
      const clusters = Math.min(5, Math.ceil(count / 6)); let placed = 0;
      for (let c = 0; c < clusters && placed < count; c++) {
        let startCell = cells[Math.floor(Math.random() * cells.length)];
        for (let attempt = 0; attempt < 20; attempt++) { const candidate = cells[Math.floor(Math.random() * cells.length)]; let hasNearbyFuel = false; [[0,1],[1,0],[0,-1],[-1,0]].forEach(([dx,dy]) => { if (grid[candidate.y + dy] && grid[candidate.y + dy][candidate.x + dx] && grid[candidate.y + dy][candidate.x + dx].type === 'fuel') hasNearbyFuel = true; }); if (c === 0 || hasNearbyFuel) { startCell = candidate; break; } }
        if (grid[startCell.y][startCell.x].type === 'empty') { grid[startCell.y][startCell.x].type = 'fuel'; placed++; }
        const queue = [startCell], visited = new Set([`${startCell.x},${startCell.y}`]);
        while (queue.length > 0 && placed < count) { const current = queue.shift(); [[0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]].forEach(([dx,dy]) => { const nx = current.x + dx, ny = current.y + dy, key = `${nx},${ny}`; if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !visited.has(key) && grid[ny][nx].type === 'empty') { if (Math.random() < 0.7) { grid[ny][nx].type = 'fuel'; visited.add(key); queue.push({ x: nx, y: ny }); placed++; } } }); }
      }
      let dampPlaced = 0, attempts = 0; while (dampPlaced < dampCount && attempts < 100) { const x = Math.floor(Math.random() * gridSize), y = Math.floor(Math.random() * gridSize); if (grid[y][x].type === 'fuel') { grid[y][x].type = 'damp'; dampPlaced++; } attempts++; }
    }

    function createCellMeshes() { cellMeshes.forEach(m => scene.remove(m)); cellMeshes = []; const offset = (gridSize * CELL_SIZE) / 2 - CELL_SIZE / 2; for (let y = 0; y < gridSize; y++) for (let x = 0; x < gridSize; x++) { const cell = grid[y][x]; let geometry, material; if (cell.type === 'water') { geometry = new THREE.PlaneGeometry(CELL_SIZE * 0.9, CELL_SIZE * 0.9); material = new THREE.MeshBasicMaterial({ color: COLORS.secondary }); } else if (cell.type === 'fuel' || cell.type === 'damp') { geometry = new THREE.PlaneGeometry(CELL_SIZE * 0.85, CELL_SIZE * 0.85); material = new THREE.MeshBasicMaterial({ color: cell.type === 'damp' ? 0x4A4A5A : COLORS.primary, transparent: true, opacity: 0.3 }); } else { geometry = new THREE.PlaneGeometry(CELL_SIZE * 0.3, CELL_SIZE * 0.3); material = new THREE.MeshBasicMaterial({ color: 0x1A1A1A, transparent: true, opacity: 0.2 }); } const mesh = new THREE.Mesh(geometry, material); mesh.position.set(x * CELL_SIZE - offset, -y * CELL_SIZE + offset, 0); mesh.userData = { x, y }; scene.add(mesh); cellMeshes.push(mesh); } }

    function initIdleGrid() { idleCells = []; idleMeshes.forEach(m => m.mesh && scene.remove(m.mesh)); idleMeshes = []; const idleSize = 7, offset = (idleSize * CELL_SIZE) / 2 - CELL_SIZE / 2; for (let y = 0; y < idleSize; y++) for (let x = 0; x < idleSize; x++) if (Math.random() < 0.35) { idleCells.push({ x, y, burning: false, burnTime: 0, fireIntensity: Math.random() }); const mesh = new THREE.Mesh(new THREE.PlaneGeometry(CELL_SIZE * 0.85, CELL_SIZE * 0.85), new THREE.MeshBasicMaterial({ color: COLORS.primary, transparent: true, opacity: 0.3 })); mesh.position.set(x * CELL_SIZE - offset, -y * CELL_SIZE + offset, 0); scene.add(mesh); idleMeshes.push({ mesh, cell: idleCells[idleCells.length - 1] }); } scheduleIdleIgnition(); }

    function scheduleIdleIgnition() { if (gameState !== 'start') return; setTimeout(() => { if (gameState !== 'start') return; const unburnt = idleCells.filter(c => !c.burning); if (unburnt.length > 0) igniteIdleCell(unburnt[Math.floor(Math.random() * unburnt.length)]); scheduleIdleIgnition(); }, 2000 + Math.random() * 2000); }

    function igniteIdleCell(cell) { if (cell.burning) return; cell.burning = true; cell.burnTime = 0; const meshObj = idleMeshes.find(m => m.cell === cell); if (meshObj) { meshObj.mesh.material.color.setHex(COLORS.accent); meshObj.mesh.material.opacity = 1; } playIgniteSound(); [[0,1],[1,0],[0,-1],[-1,0]].forEach((dir, i) => { setTimeout(() => { const n = idleCells.find(c => c.x === cell.x + dir[0] && c.y === cell.y + dir[1]); if (n && !n.burning && gameState === 'start') igniteIdleCell(n); }, Math.random() * 200); }); [[1,1],[-1,-1],[1,-1],[-1,1]].forEach((dir, i) => { setTimeout(() => { const n = idleCells.find(c => c.x === cell.x + dir[0] && c.y === cell.y + dir[1]); if (n && !n.burning && gameState === 'start') igniteIdleCell(n); }, 300 + Math.random() * 200); }); setTimeout(() => { if (gameState === 'start' && meshObj) { cell.burning = false; meshObj.mesh.material.color.setHex(COLORS.primary); meshObj.mesh.material.opacity = 0.3; } }, 4000 + Math.random() * 3000); }

    function updateIdleAnimation(delta) { idleCells.forEach(cell => { if (cell.burning) { cell.fireIntensity = 0.7 + Math.sin(Date.now() * 0.01 + cell.x * 0.5) * 0.3; const meshObj = idleMeshes.find(m => m.cell === cell); if (meshObj) { const f = cell.fireIntensity; meshObj.mesh.material.opacity = 0.6 + f * 0.4; meshObj.mesh.material.color.setRGB(1, 0.98 * f + 0.42 * (1 - f), 0.94 * f + 0.1 * (1 - f)); } } }); }

    function igniteCell(x, y) { if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return; const cell = grid[y][x]; if (cell.type === 'water' || cell.burning) return; if (cell.type === 'fuel') { cell.burning = true; cell.burnTime = 0; fireActiveCount++; hasEverIgnited = true; playIgniteSound(); updateCellMesh(x, y); checkWinCondition(); } else if (cell.type === 'damp') { cell.burning = true; cell.burnTime = -3; fireActiveCount++; playDampSound(); updateCellMesh(x, y); } }

    function updateCellMesh(x, y) { const cell = grid[y][x]; const mesh = cellMeshes.find(m => m.userData.x === x && m.userData.y === y); if (!mesh) return; if (cell.burning) { mesh.material.color.setHex(COLORS.accent); mesh.material.opacity = 1; } else if (cell.type === 'damp') { mesh.material.color.setHex(0x4A4A5A); mesh.material.opacity = 0.5; } else if (cell.type === 'fuel') { mesh.material.color.setHex(COLORS.primary); mesh.material.opacity = 0.5; } }

    function spreadFire(delta) { const spreadSpeed = 1.5, spreadInterval = 1 / spreadSpeed; for (let y = 0; y < gridSize; y++) for (let x = 0; x < gridSize; x++) { const cell = grid[y][x]; if (cell.burning && cell.type !== 'water') { cell.burnTime += delta; if (cell.type === 'damp' && cell.burnTime < 0) continue; [[0,1],[1,0],[0,-1],[-1,0]].forEach(([dx,dy]) => { if (cell.burnTime > spreadInterval * 0.5) { const nx = x + dx, ny = y + dy; if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && grid[ny][nx].type !== 'water' && !grid[ny][nx].burning && (grid[ny][nx].type === 'fuel' || grid[ny][nx].type === 'damp')) igniteCell(nx, ny); } }); [[1,1],[-1,-1],[1,-1],[-1,1]].forEach(([dx,dy]) => { if (cell.burnTime > spreadInterval * 0.5 + 0.3) { const nx = x + dx, ny = y + dy; if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && grid[ny][nx].type !== 'water' && !grid[ny][nx].burning && (grid[ny][nx].type === 'fuel' || grid[ny][nx].type === 'damp')) igniteCell(nx, ny); } }); if (cell.burnTime > 6) { cell.burning = false; fireActiveCount--; updateCellMesh(x, y); } } } checkLoseCondition(); }

    function updateFireVisuals(delta) { cellMeshes.forEach(mesh => { const { x, y } = mesh.userData, cell = grid[y][x]; if (cell.burning && (cell.type === 'fuel' || cell.type === 'damp')) { const f = 0.8 + Math.sin(Date.now() * 0.01 + x * 0.5 + y * 0.7) * 0.2; mesh.material.opacity = Math.min(1, f); const i = cell.type === 'damp' ? 0.5 : 1; mesh.material.color.setRGB(f, 0.98 * i * f, 0.94 * i * f); } }); }

    function checkWinCondition() { let totalFuel = 0, burningFuel = 0; for (let y = 0; y < gridSize; y++) for (let x = 0; x < gridSize; x++) { const cell = grid[y][x]; if (cell.type === 'fuel') { totalFuel++; if (cell.burning) burningFuel++; } else if (cell.type === 'damp') { totalFuel++; if (cell.burning && cell.burnTime > 0) burningFuel++; } } if (burningFuel === totalFuel && totalFuel > 0) { if (!allFuelIgnitedTime) allFuelIgnitedTime = Date.now(); else if (Date.now() - allFuelIgnitedTime >= 500) endGame(true); } else allFuelIgnitedTime = null; }

    function checkLoseCondition() { if (!hasEverIgnited) return; const burning = []; for (let y = 0; y < gridSize; y++) for (let x = 0; x < gridSize; x++) if (grid[y][x].burning) burning.push({ x, y }); const visited = new Set(), queue = [...burning]; while (queue.length > 0) { const { x, y } = queue.shift(), key = `${x},${y}`; if (visited.has(key) || grid[y][x].type === 'water') continue; visited.add(key); [[0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]].forEach(([dx,dy]) => { const nx = x + dx, ny = y + dy; if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !visited.has(`${nx},${ny}`) && grid[ny][nx].type !== 'water') queue.push({ x: nx, y: ny }); }); } let hasUnreachableFuel = false; for (let y = 0; y < gridSize && !hasUnreachableFuel; y++) for (let x = 0; x < gridSize; x++) if ((grid[y][x].type === 'fuel' || grid[y][x].type === 'damp') && !grid[y][x].burning && !visited.has(`${x},${y}`)) { hasUnreachableFuel = true; break; } const hasActiveFire = grid.some(row => row.some(c => c.burning)); if (hasUnreachableFuel && !hasActiveFire) endGame(false); }

    function calculateScore() { let totalFuel = 0, burningFuel = 0; for (let y = 0; y < gridSize; y++) for (let x = 0; x < gridSize; x++) { const cell = grid[y][x]; if (cell.type === 'fuel' || cell.type === 'damp') { totalFuel++; if (cell.burning && (cell.type !== 'damp' || cell.burnTime > 0)) burningFuel++; } } let finalScore = burningFuel * 100; if ((Date.now() - gameStartTime) / 1000 < LEVELS[currentLevel].par) finalScore += 50; if (burningFuel === totalFuel && totalFuel > 0) finalScore += 200; return finalScore; }

    function endGame(won) { gameState = 'result'; const finalScore = won ? calculateScore() : 0; score = finalScore; if (won) { saveHighScore(finalScore); playWinSound(); } else playLoseSound(); highScore = getHighScore(); resultTitle.textContent = won ? 'IGNITED' : 'EXTINGUISHED'; resultTitle.style.color = won ? '#FF6B1A' : '#666666'; resultScore.textContent = won ? 'Score: ' + finalScore : 'The fire could not reach all cells.'; nextLevelBtn.style.display = won && currentLevel < LEVELS.length - 1 ? 'inline-block' : 'none'; restartBtn.style.display = won ? 'none' : 'inline-block'; resultScreen.classList.add('visible'); }

    function startGame() { idleMeshes.forEach(m => m.mesh && scene.remove(m.mesh)); idleMeshes = []; idleCells = []; const level = LEVELS[currentLevel]; gridSize = level.gridSize; createGrid(level.gridSize); placeWaterBarriers(level.water); placeFuelCells(level.fuel, level.damp); createCellMeshes(); gameStartTime = Date.now(); allFuelIgnitedTime = null; fireActiveCount = 0; hasEverIgnited = false; gameState = 'playing'; gameUI.classList.add('visible'); levelInfo.textContent = (currentLevel + 1) + '. ' + level.name; highScoreInfo.textContent = 'Best: ' + getHighScore(); resultScreen.classList.remove('visible'); }

    function onPointerDown(e) { if (gameState !== 'playing') return; const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top; const worldX = (x / rect.width) * 2 - 1, worldY = -((y / rect.height) * 2 - 1); const aspect = window.innerWidth / window.innerHeight, frustumSize = 400; let px, py; if (aspect < 1) { px = worldX * frustumSize * aspect / 2; py = worldY * frustumSize / 2; } else { px = worldX * frustumSize / 2; py = worldY * frustumSize / aspect / 2; } const offset = (gridSize * CELL_SIZE) / 2 - CELL_SIZE / 2; const gridX = Math.round((px + offset) / CELL_SIZE), gridY = Math.round((-py + offset) / CELL_SIZE); if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) { const cell = grid[gridY][gridX]; if ((cell.type === 'fuel' || cell.type === 'damp') && !cell.burning) { playSeedSound(); igniteCell(gridX, gridY); } } }

    function animate() { requestAnimationFrame(animate); const delta = clock.getDelta(); if (gameState === 'start') { updateIdleAnimation(delta); } else if (gameState === 'playing') { spreadFire(delta); updateFireVisuals(delta); } composer.render(); }

    initThree();
    initIdleGrid();
    animate();

    startScreen.addEventListener('pointerdown', () => { gameState = 'playing'; startScreen.classList.add('hidden'); startGame(); initAudio().catch(() => {}); }, { once: true });
    canvas.addEventListener('pointerdown', onPointerDown);
    nextLevelBtn.addEventListener('pointerdown', () => { currentLevel++; startGame(); });
    restartBtn.addEventListener('pointerdown', () => { startGame(); });
  </script>
</body>
</html>